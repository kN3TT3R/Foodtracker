//
//  RatingControl.swift
//  Foodtracker
//
//  Created by Kenneth Debruyn on 5/02/17.
//  Copyright © 2017 kN3TT3R. All rights reserved.
//

/*
        To be able to rate a meal, users need a control that lets them select the number of stars they want to assign to the meal. 
        You’ll create a stack view subclass that manages a row of buttons representing the stars. 
        You’ll define your custom control entirely in code, and then add it to your storyboard.
 
        When a user taps a star, that star and the stars preceding it are filled in. If the user taps the rightmost filled in star (the star associated with the current rating), the rating is cleared and all stars are displayed as empty.
 
        You typically create a view in one of two ways: by programatically initializing the view, or by allowing the view to be loaded by the storyboard.
        There’s a corresponding initializer for each approach: 
            - init(frame:) for programatically initializing the view and 
            - init?(coder:) for loading the view from the storyboard.
 
        Recall that an initializer is a method that prepares an instance of a class for use, which involves setting an initial value for each property and performing any other setup.
 
        You will need to implement both of these methods in your custom control. While designing the app, Interface Builder programatically instantiates the view when you add it to the canvas. At runtime, your app loads the view from the storyboard.
    
        Swift handles initializers differently than other methods. If you don’t provide any initializers, Swift classes automatically inherit all of their super class’s designated initializers. If you implement any initializers, you not longer inherit any of the superclasses initializers; however, the superclass can mark one or more of its initializers as required. The subclass must implement (or automatically inherit) all of the required initializers. Furthermore, the subclass must mark their initializers as required, indicating that their subclasses must also implement the initializers.
 */

import UIKit


@IBDesignable class RatingControl: UIStackView {
    
    
    //MARK: - Properties
    private var ratingButtons = [UIButton]()
    var rating = 0 {
        didSet {
            updateButtonSelectionStates()
        }
    }
    
    @IBInspectable var starSize: CGSize = CGSize(width: 44.0, height: 44.0) {
        didSet {
            setupButtons()
        }
    }
    @IBInspectable var starCount: Int = 5 {
        didSet {
            setupButtons()
        }
    }
    
    
    //MARK: Initialization
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupButtons()
    }
    required init(coder: NSCoder) {
        super.init(coder: coder)
        setupButtons()
    }
    
    
    // MARK: - Button Action
    func ratingButtonTapped(button: UIButton) {
        
        guard let index = ratingButtons.index(of: button) else {
            fatalError("The button, \(button), is not in the ratingButtons array: \(ratingButtons)")
        }
        
        // Calculate the rating of the selected button
        let selectedRating = index + 1
        
        if selectedRating == rating {
            // If the selected star represents the current rating, reset the rating to 0.
            rating = 0
        } else {
            // Otherwise set the rating to the selected star
            rating = selectedRating
        }
        
    }
    
    
    //MARK: Private Methods
    private func setupButtons() {
        
        
        // clear any existing buttons
        for button in ratingButtons {
            removeArrangedSubview(button)
            button.removeFromSuperview()
        }
        
        ratingButtons.removeAll()
        
        
        // Load Button Images
        let bundle = Bundle(for: type(of: self))
        let filledStar = UIImage(named: "filledStar", in: bundle, compatibleWith: self.traitCollection)
        let emptyStar = UIImage(named:"emptyStar", in: bundle, compatibleWith: self.traitCollection)
        let highlightedStar = UIImage(named:"highlightedStar", in: bundle, compatibleWith: self.traitCollection)
        

        // Create 5 button in the ratingbar
        for index in 0..<starCount {
        
            // Create the button
            let button = UIButton()
            // button.backgroundColor = UIColor.red
        
            
            // Set the button images
            button.setImage(emptyStar, for: .normal)
            button.setImage(filledStar, for: .selected)
            button.setImage(highlightedStar, for: .highlighted)
            button.setImage(highlightedStar, for: [.highlighted, .selected])
            
            
            // Add constraints
            // when using Auto Layout, it’s a good habit to explicitly disable the autogenerated constraints whenever you programmatically create a view
            // disables the button’s automatically generated constraints
            button.translatesAutoresizingMaskIntoConstraints = false
            button.heightAnchor.constraint(equalToConstant: starSize.height).isActive = true
            button.widthAnchor.constraint(equalToConstant: starSize.width).isActive = true
            
            
            // Set the accessibility label
            button.accessibilityLabel = "Set \(index + 1) star rating"
            
            
            // Setup the button action
            // target-action pattern to link elements in your storyboard to action methods in your code
            button.addTarget(self, action: #selector(RatingControl.ratingButtonTapped(button:)), for: .touchUpInside)
            
            // Add the button to the stack
            addArrangedSubview(button)
            
            // Add the new button to the rating button array
            ratingButtons.append(button)
        }
        
        updateButtonSelectionStates()
    }
    
    private func updateButtonSelectionStates() {
        
        for (index, button) in ratingButtons.enumerated() {
            // If the index of a button is less than the rating, that button should be selected.
            button.isSelected = index < rating
            
            
            // Set the hint string for the currently selected star
            let hintString: String?
            if rating == index + 1 {
                hintString = "Tap to reset the rating to zero."
            } else {
                hintString = nil
            }
            
            // Calculate the value string
            let valueString: String
            switch (rating) {
            case 0:
                valueString = "No rating set."
            case 1:
                valueString = "1 star set."
            default:
                valueString = "\(rating) stars set."
            }
            
            // Assign the hint string and value string
            button.accessibilityHint = hintString
            button.accessibilityValue = valueString
            
        }
        
    }
    
}











